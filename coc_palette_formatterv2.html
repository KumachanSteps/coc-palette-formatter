<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NJD5JZML31"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NJD5JZML31');
</script>
<meta charset="UTF-8">
<title>CoCã‚­ãƒ£ãƒ©ã‚·ãƒ¼ãƒˆæ•´å½¢ãƒ„ãƒ¼ãƒ« V2</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 40px;
  background-color: #f9f9f9;
  display: flex;
  flex-direction: column;
  align-items: center;
}
header {
  margin-bottom: 30px;
  text-align: center;
}
header h1 {
  font-size: 28px;
  color: #333;
}
header p {
  font-size: 14px;
  color: #555;
}
.main {
  display: flex;
  justify-content: center;
  gap: 30px;
  max-width: 1200px;
  width: 100%;
}
.container {
  flex: 1;
  display: flex;
  flex-direction: column;
  max-width: 550px;
}
textarea {
  width: 100%;
  height: 600px;
  resize: none;
  padding: 10px;
  font-family: monospace;
  font-size: 14px;
  background-color: #fff;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-sizing: border-box;
}
button {
  margin-top: 10px;
  padding: 10px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  background-color: #007acc;
  color: #fff;
  transition: background-color 0.3s;
}
button:hover {
  background-color: #005f99;
}
</style>
</head>
<body>

<header>
  <h1>CoCã‚­ãƒ£ãƒ©ã‚·ãƒ¼ãƒˆæ•´å½¢ãƒ„ãƒ¼ãƒ« V2</h1>
  <p>ã€ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä¿ç®¡æ‰€ã€ã®ã€Œãƒ‡ãƒ¼ã‚¿å‡ºåŠ›â–¶ï¸ãƒ†ã‚­ã‚¹ãƒˆã€ã‚’ãƒãƒ£ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆã«æ•´å½¢ã—ã¾ã™ã€‚</p>
</header>

<div class="main">
  <div class="container">
    <textarea id="input" placeholder="ã“ã“ã«ãƒãƒ£ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„"></textarea>
    <button onclick="formatPalette()">åˆ†é¡ã—ã¦å‡ºåŠ›</button>
  </div>

  <div class="container">
    <textarea id="output" readonly></textarea>
    <button onclick="copyOutput()">ã‚³ãƒ”ãƒ¼</button>
  </div>
</div>

<script>
const initialValues = {
  'ç›®æ˜Ÿ': 25, 'å›³æ›¸é¤¨': 25, 'èãè€³': 25, 'ã‚­ãƒƒã‚¯': 25, 'çµ„ã¿ä»˜ã': 25, 'é ­çªã': 10, 'æŠ•æ“²': 25, 'ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„': 1,
  'æ‹³éŠƒ': 20, 'ã‚µãƒ–ãƒã‚·ãƒ³ã‚¬ãƒ³': 15, 'ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³': 30, 'ãƒã‚·ãƒ³ã‚¬ãƒ³': 15, 'ãƒ©ã‚¤ãƒ•ãƒ«': 25,
  'å¿œæ€¥æ‰‹å½“': 30, 'éµé–‹ã‘': 1, 'éš ã™': 15, 'éš ã‚Œã‚‹': 10, 'å¿ã³æ­©ã': 10, 'å†™çœŸè¡“': 10, 'ç²¾ç¥åˆ†æ': 1,
  'è¿½è·¡': 10, 'ç™»æ”€': 40, 'é‹è»¢': 20, 'æ©Ÿæ¢°ä¿®ç†': 20, 'é‡æ©Ÿæ¢°æ“ä½œ': 1, 'ä¹—é¦¬': 5, 'æ°´æ³³': 25,
  'è£½ä½œ': 5, 'æ“ç¸¦': 1, 'è·³èº': 25, 'é›»æ°—ä¿®ç†': 10, 'ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ': 10, 'å¤‰è£…': 1,
  'è¨€ã„ãã‚‹ã‚': 5, 'ä¿¡ç”¨': 15, 'èª¬å¾—': 15, 'å€¤åˆ‡ã‚Š': 5,
  'åŒ»å­¦': 5, 'ã‚ªã‚«ãƒ«ãƒˆ': 5, 'åŒ–å­¦': 1, 'èŠ¸è¡“': 5, 'çµŒç†': 10, 'è€ƒå¤å­¦': 1, 'ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼': 1,
  'å¿ƒç†å­¦': 5, 'äººé¡å­¦': 1, 'ç”Ÿç‰©å­¦': 1, 'åœ°è³ªå­¦': 1, 'é›»å­å·¥å­¦': 1, 'å¤©æ–‡å­¦': 1, 'åšç‰©å­¦': 10, 'ç‰©ç†å­¦': 1, 'æ³•å¾‹': 5, 'è–¬å­¦': 1, 'æ­´å²': 20,
  'ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±': 0, // ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±ã®åˆæœŸå€¤ã‚’æ˜ç¤ºçš„ã«å®šç¾©
  'ã“ã¶ã—': 50, // ã“ã¶ã—ï¼ˆãƒ‘ãƒ³ãƒï¼‰ã®åˆæœŸå€¤ã‚’å®šç¾©
  'å›é¿': 0 // å›é¿ã®åˆæœŸå€¤ã‚’å®šç¾©ï¼ˆDEX*2ã§è¨ˆç®—ã•ã‚Œã‚‹ãŸã‚0ã‚’è¨­å®šï¼‰
  // 'æ¯å›½èª' ã¯EDU*5ã§æ´¾ç”Ÿã™ã‚‹ãŸã‚ã€initialValuesã«ã¯å«ã‚ãªã„
};

function formatPalette() {
  const inputContent = document.getElementById("input").value;
  const lines = inputContent.split("\n");
  
  const outputLines = []; // æœ€çµ‚çš„ãªå‡ºåŠ›è¡Œã‚’æ ¼ç´ã™ã‚‹é…åˆ—
  // presentSkills map: skillNameNormalized -> { value: number, hasBullet: boolean, rawName: string, originalLineIndex: number }
  const presentSkills = new Map(); // å…¥åŠ›ã‹ã‚‰æŠ½å‡ºã—ãŸæŠ€èƒ½ã¨ãã®å€¤ã‚’æ ¼ç´

  let str = 0, con = 0, pow = 0, dex = 0, app = 0, siz = 0, int = 0, edu = 0;
  let damageBonus = "0"; 
  let sanValue = 70; 

  // Define skills that always appear in main sections, even if their value matches initial values and they have no bullet.
  // 'æ¯å›½èª' ã‚’ã“ã“ã«è¿½åŠ 
  const specialSkillsAlwaysInMainCategory = new Set(["ã“ã¶ã—", "å›é¿", "æ¯å›½èª"]); 

  // Define skills that appear at the very top of the output, outside the main categorized sections.
  // These are handled separately and should not appear in initial section.
  const topLevelFixedSkills = new Set(["ã‚¢ã‚¤ãƒ‡ã‚¢", "å¹¸é‹", "çŸ¥è­˜", "ç›®æ˜Ÿ", "èãè€³", "å›³æ›¸é¤¨"]);
  // ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±ã¯çŸ¥è­˜ç³»æŠ€èƒ½ã®æœ€å¾Œã«å‡ºåŠ›ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§é™¤å¤–ã—ãªã„

  // This set tracks all skills that have been placed into the final output, regardless of section.
  const processedSkillsInFinalOutput = new Set(); 

  // --- æœ€åˆã®ãƒ‘ã‚¹: å…¨ã¦ã®ã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿ï¼ˆèƒ½åŠ›å€¤ã€SANã€ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒœãƒ¼ãƒŠã‚¹ã€å…¨ã¦ã®æŠ€èƒ½ï¼‰ã‚’æŠ½å‡º ---
  lines.forEach((line, i) => { // Added 'i' for originalLineIndex
    // èƒ½åŠ›å€¤ã‚’æŠ½å‡º
    const statsMatch = line.match(/^=åˆè¨ˆ=\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/);
    if (statsMatch) {
      str = parseInt(statsMatch[1], 10);
      con = parseInt(statsMatch[2], 10);
      pow = parseInt(statsMatch[3], 10);
      dex = parseInt(statsMatch[4], 10);
      app = parseInt(statsMatch[5], 10);
      siz = parseInt(statsMatch[6], 10);
      int = parseInt(statsMatch[7], 10);
      edu = parseInt(statsMatch[8], 10);
    }

    // ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒœãƒ¼ãƒŠã‚¹ã‚’æŠ½å‡º
    const damageBonusMatch = line.match(/ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒœãƒ¼ãƒŠã‚¹ï¼š(.+)/);
    if (damageBonusMatch) { damageBonus = damageBonusMatch[1].trim(); }
    
    // SANå€¤ã‚’æŠ½å‡º (ä¾‹: SAN: 70/99)
    const sanMatch = line.match(/SANï¼š(\d+)\/\d+/);
    if (sanMatch) { sanValue = parseInt(sanMatch[1], 10); }

    // æŠ€èƒ½ã‚’ãƒ‘ãƒ¼ã‚¹: (â—)?ã€ŠæŠ€èƒ½åã€‹å€¤%?
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«æ­£è¦èªå¥ã‚’ä½¿ç”¨ã—ã¦ã€1è¡Œå†…ã®å…¨ã¦ã®æŠ€èƒ½ã‚’æ¤œç´¢
    const skillMatches = line.matchAll(/(â—)?ã€Š([^ã€‹]+)ã€‹\s*(\d+)%?/g);
    for (const match of skillMatches) {
      const hasBullet = !!match[1];
      const rawSkillName = match[2].trim();
      let skillNameNormalized = rawSkillName
        .replace(/[\s\uFEFF\xA0ã€€\u2000-\u200A\u202F\u205F\u3000]+/g, '') // å¹…åºƒã„ç©ºç™½æ–‡å­—
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') // åˆ¶å¾¡æ–‡å­—
        .replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, '') // å…¨è§’æ‹¬å¼§å†…ã®å†…å®¹ã‚’å‰Šé™¤
        .replace(/\([^)]*\)/g, '') // åŠè§’æ‹¬å¼§å†…ã®å†…å®¹ã‚’å‰Šé™¤
        .replace(/[^\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}\p{Number}\p{Alphabetic}]/gu, '') // æ—¥æœ¬èªã€æ•°å­—ã€è‹±å­—ä»¥å¤–ã‚’å‰Šé™¤ (uãƒ•ãƒ©ã‚°ãŒå¿…è¦)
        .trim(); // å¿µã®ãŸã‚å‰å¾Œã®ç©ºç™½ã‚’å‰Šé™¤

      // Store all found skills with their original line index
      presentSkills.set(skillNameNormalized, { value: parseInt(match[3], 10), hasBullet: hasBullet, rawName: rawSkillName, originalLineIndex: i });
    }
  });

  // æŠ€èƒ½å€¤ã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  // å„ªå…ˆé †ä½: 1. presentSkills (å…¥åŠ›ãƒ‡ãƒ¼ã‚¿) -> 2. æ´¾ç”Ÿå€¤ (ã‚¢ã‚¤ãƒ‡ã‚¢ã€å¹¸é‹ã€çŸ¥è­˜ã€å›é¿ã€æ¯å›½èªã®ã¿) -> 3. initialValues (ãã®ä»–æŠ€èƒ½ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯) -> 4. 0
  const getSkillValue = (skillName) => {
      if (presentSkills.has(skillName)) {
          return presentSkills.get(skillName).value;
      }
      // ã‚¢ã‚¤ãƒ‡ã‚¢ã€å¹¸é‹ã€çŸ¥è­˜ã€å›é¿ã€æ¯å›½èª ã®ã¿ã“ã“ã§æ´¾ç”Ÿå€¤ã‚’è¨ˆç®—
      if (skillName === "ã‚¢ã‚¤ãƒ‡ã‚¢") return int * 5;
      if (skillName === "å¹¸é‹") return pow * 5;
      if (skillName === "çŸ¥è­˜") return edu * 5;
      if (skillName === "å›é¿") return dex * 2; // å›é¿ã®è¨ˆç®—ã‚’è¿½åŠ 
      if (skillName === "æ¯å›½èª") return edu * 5; // æ¯å›½èªã®è¨ˆç®—ã‚’è¿½åŠ 
      
      // ãã‚Œä»¥å¤–ã®æŠ€èƒ½ã§presentSkillsã«ãªã„å ´åˆã€initialValuesã‹ã‚‰å–å¾—
      if (initialValues.hasOwnProperty(skillName)) {
          return initialValues[skillName];
      }
      return 0; // ã©ã“ã«ã‚‚ãªã„å ´åˆã€0ã‚’è¿”ã™
  };

  // --- å‡ºåŠ›æ§‹ç¯‰: â—¼ï¸ãƒ€ã‚¤ã‚¹ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ---
  outputLines.push(`â—¼ï¸ãƒ€ã‚¤ã‚¹`);
  outputLines.push(`1d100<={SAN} ã€æ­£æ°—åº¦ãƒ­ãƒ¼ãƒ«ã€‘`); 
  outputLines.push(`CCB<=${getSkillValue("ã‚¢ã‚¤ãƒ‡ã‚¢")} ã€ã‚¢ã‚¤ãƒ‡ã‚¢ã€‘`);
  outputLines.push(`CCB<=${getSkillValue("å¹¸é‹")} ã€å¹¸é‹ã€‘`);
  outputLines.push(`CCB<=${getSkillValue("çŸ¥è­˜")} ã€çŸ¥è­˜ã€‘`);
  processedSkillsInFinalOutput.add("ã‚¢ã‚¤ãƒ‡ã‚¢");
  processedSkillsInFinalOutput.add("å¹¸é‹");
  processedSkillsInFinalOutput.add("çŸ¥è­˜");

  outputLines.push(``); 
  outputLines.push(`ğŸŸ¦æ¢ç´¢æŠ€èƒ½`);
  outputLines.push(`CCB<=${getSkillValue("ç›®æ˜Ÿ")} ã€ç›®æ˜Ÿã€‘`);
  outputLines.push(`CCB<=${getSkillValue("èãè€³")} ã€èãè€³ã€‘`);
  outputLines.push(`CCB<=${getSkillValue("å›³æ›¸é¤¨")} ã€å›³æ›¸é¤¨ã€‘`);
  processedSkillsInFinalOutput.add("ç›®æ˜Ÿ");
  processedSkillsInFinalOutput.add("èãè€³");
  processedSkillsInFinalOutput.add("å›³æ›¸é¤¨");

  // å‡ºåŠ›ç”¨ã®ãƒ˜ãƒƒãƒ€ãƒ¼å®šç¾©
  const outputSectionHeadersMap = {
    "æˆ¦é—˜ç³»æŠ€èƒ½": "ğŸŸ¥æˆ¦é—˜æŠ€èƒ½",
    "è¡Œå‹•ç³»æŠ€èƒ½": "ğŸŸ§è¡Œå‹•æŠ€èƒ½ãƒ»ä»–", 
    "äº¤æ¸‰ç³»æŠ€èƒ½": "ğŸŸªäº¤æ¸‰æŠ€èƒ½",
    "çŸ¥è­˜ç³»æŠ€èƒ½": "â¬œï¸çŸ¥è­˜æŠ€èƒ½"
  };

  // å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ˜ãƒƒãƒ€ãƒ¼ã¨ã€ãã‚Œã«å¯¾å¿œã™ã‚‹å†…éƒ¨çš„ãªã‚«ãƒ†ã‚´ãƒªã‚­ãƒ¼ã®ãƒãƒƒãƒ”ãƒ³ã‚°
  const inputHeaderToCategoryMap = {
    "------------------------ æˆ¦é—˜ç³»æŠ€èƒ½ ------------------------": "æˆ¦é—˜ç³»æŠ€èƒ½",
    "------------------------ æ¢ç´¢ç³»æŠ€èƒ½ ------------------------": "è¡Œå‹•ç³»æŠ€èƒ½", // æ¢ç´¢ç³»æŠ€èƒ½ã®å‡ºåŠ›å…ˆã‚’è¡Œå‹•ç³»æŠ€èƒ½ã«ãƒãƒƒãƒ”ãƒ³ã‚°
    "------------------------ è¡Œå‹•ç³»æŠ€èƒ½ ------------------------": "è¡Œå‹•ç³»æŠ€èƒ½",
    "------------------------ äº¤æ¸‰ç³»æŠ€èƒ½ ------------------------": "äº¤æ¸‰ç³»æŠ€èƒ½",
    "------------------------ çŸ¥è­˜ç³»æŠ€èƒ½ ------------------------": "çŸ¥è­˜ç³»æŠ€èƒ½"
  };

  // å„æŠ€èƒ½ã‚«ãƒ†ã‚´ãƒªã®ãƒªã‚¹ãƒˆã‚’ä¸€æ™‚çš„ã«ä¿æŒã™ã‚‹ãƒãƒƒãƒ—
  const categorizedMainSkills = {
      "æˆ¦é—˜ç³»æŠ€èƒ½": [],
      "è¡Œå‹•ç³»æŠ€èƒ½": [], 
      "äº¤æ¸‰ç³»æŠ€èƒ½": [],
      "çŸ¥è­˜ç³»æŠ€èƒ½": []
  };

  const initialSectionCandidates = []; // For ========åˆæœŸå€¤======== section, preserving input order

  let currentInputSectionKey = null;

  // Iterate through the original lines to categorize skills based on their section and rules
  const skillBlockStartIndex = lines.findIndex(line => line.trim() === "â– æŠ€èƒ½â– ");
  const combatSectionStartIndex = lines.findIndex(line => line.trim() === "â– æˆ¦é—˜â– ");

  if (skillBlockStartIndex !== -1) {
      for (let i = skillBlockStartIndex; i < combatSectionStartIndex; i++) { 
          const line = lines[i];
          const trimmedLine = line.trim();

          const inputHeader = Object.keys(inputHeaderToCategoryMap).find(header => trimmedLine === header);
          if (inputHeader) {
              currentInputSectionKey = inputHeaderToCategoryMap[inputHeader];
              continue; 
          }

          if (trimmedLine.startsWith("ç¿’å¾—/åå‰")) {
              continue;
          }

          const skillMatches = line.matchAll(/(â—)?ã€Š([^ã€‹]+)ã€‹\s*(\d+)%?/g);
          for (const match of skillMatches) {
              const hasBullet = !!match[1]; 
              const rawSkillName = match[2].trim(); 
              const skillValue = parseInt(match[3], 10);
              let skillNameNormalized = rawSkillName
                .replace(/[\s\uFEFF\xA0ã€€\u2000-\u200A\u202F\u205F\u3000]+/g, '') 
                .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') 
                .replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, '').replace(/\([^)]*\)/g, '') 
                .replace(/[^\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}\p{Number}\p{Alphabetic}]/gu, '') 
                .trim();
              
              if (processedSkillsInFinalOutput.has(skillNameNormalized)) {
                  continue; // Already placed in top-level sections
              }

              const formattedSkillLine = `CCB<=${skillValue} ã€${rawSkillName}ã€‘`;
              
              const isSpecialException = specialSkillsAlwaysInMainCategory.has(skillNameNormalized);
              const hasInitialValueDefined = initialValues.hasOwnProperty(skillNameNormalized);
              const isValueMatchingInitial = hasInitialValueDefined && skillValue === initialValues[skillNameNormalized];

              // Rule: Initial value skills go to initial section UNLESS they are special exceptions or have a bullet.
              if (isSpecialException || hasBullet || (hasInitialValueDefined && !isValueMatchingInitial)) {
                  let targetCategory = currentInputSectionKey;
                  // æ¯å›½èªã¯äº¤æ¸‰æŠ€èƒ½ã«å¼·åˆ¶çš„ã«åˆ†é¡
                  if (skillNameNormalized === "æ¯å›½èª") {
                      targetCategory = "äº¤æ¸‰ç³»æŠ€èƒ½";
                  } else if (targetCategory === "æ¢ç´¢ç³»æŠ€èƒ½") { 
                      targetCategory = "è¡Œå‹•ç³»æŠ€èƒ½";
                  }
                  if (categorizedMainSkills[targetCategory]) {
                      categorizedMainSkills[targetCategory].push({ name: skillNameNormalized, line: formattedSkillLine, originalLineIndex: i });
                      processedSkillsInFinalOutput.add(skillNameNormalized); // Mark as processed for main section
                  }
              } else {
                  // This skill is an initial value skill (no bullet, value matches initial, not a special exception)
                  initialSectionCandidates.push({ name: skillNameNormalized, line: formattedSkillLine, originalLineIndex: i });
                  processedSkillsInFinalOutput.add(skillNameNormalized); // Mark as processed for initial section
              }
          }
      }
  }

  // Add skills from initialValues that were not found in the input at all
  // These should also appear in the initial section, at the end of the input-found initial skills.
  Object.entries(initialValues).forEach(([skillName, initialVal]) => {
      const skillNameNormalized = skillName; // Keys of initialValues are already normalized
      
      // Check if this skill has already been processed and placed in any output section
      if (!processedSkillsInFinalOutput.has(skillNameNormalized)) {
          // Check if it's a top-level fixed skill (e.g., ã‚¢ã‚¤ãƒ‡ã‚¢, ç›®æ˜Ÿ) that are handled separately
          if (!topLevelFixedSkills.has(skillNameNormalized) && !specialSkillsAlwaysInMainCategory.has(skillNameNormalized)) {
              initialSectionCandidates.push({ name: skillNameNormalized, line: `CCB<=${initialVal} ã€${skillName}ã€‘`, originalLineIndex: Infinity }); // Use Infinity to sort them last
              processedSkillsInFinalOutput.add(skillNameNormalized); // Mark as processed
          }
      }
  });

  // Sort initialSectionCandidates: ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±ã‚’æœ€å¾Œã«ã€ãã‚Œä»¥å¤–ã¯originalLineIndexé †
  initialSectionCandidates.sort((a, b) => {
      const nameA = a.name;
      const nameB = b.name;

      if (nameA === "ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±" && nameB !== "ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±") {
          return 1; // A (ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±) comes after B
      }
      if (nameA !== "ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±" && nameB === "ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±") {
          return -1; // A comes before B (ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±)
      }
      // If both are ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©± or neither are, sort by originalLineIndex
      return a.originalLineIndex - b.originalLineIndex;
  });


  // --- Add main categorized skills to outputLines ---
  Object.keys(outputSectionHeadersMap).forEach(internalCategoryName => {
      const headerText = outputSectionHeadersMap[internalCategoryName];
      const skillsInThisSection = categorizedMainSkills[internalCategoryName];

      if (skillsInThisSection && skillsInThisSection.length > 0) {
          outputLines.push(""); // ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“ã®ç©ºè¡Œ
          outputLines.push(headerText); // æ–°ã—ã„ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ 

          let cthulhuMythosLine = null;
          let otherSkills = [];

          if (internalCategoryName === "çŸ¥è­˜ç³»æŠ€èƒ½") {
              cthulhuMythosLine = skillsInThisSection.find(s => s.name === "ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±");
              otherSkills = skillsInThisSection.filter(s => s.name !== "ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±");
          } else {
              otherSkills = skillsInThisSection;
          }
          
          otherSkills.sort((a, b) => a.name.localeCompare(b.name, 'ja', { sensitivity: 'base' }));
          otherSkills.forEach(skill => outputLines.push(skill.line));
          if (cthulhuMythosLine) {
              outputLines.push(cthulhuMythosLine.line); // ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±ã‚’æœ€å¾Œã«è¿½åŠ  (ãƒ¡ã‚¤ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…)
          }
      }
  });

  // --- ========åˆæœŸå€¤======== ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ç”Ÿæˆ ---
  if (initialSectionCandidates.length > 0) {
      outputLines.push("\n========åˆæœŸå€¤========");
      initialSectionCandidates.forEach(skill => outputLines.push(skill.line));
  }


  // --- å‡ºåŠ›æ§‹ç¯‰: ========èƒ½åŠ›å€¤======== ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ---
  outputLines.push("\n========èƒ½åŠ›å€¤========"); 
  outputLines.push(`1d3+${damageBonus} ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€‘`); 
  outputLines.push(`1d4+${damageBonus} ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€‘`); 
  outputLines.push(`1d6+${damageBonus} ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€‘`); 
  outputLines.push(`CCB<=${str * 5} ã€STR Ã— 5ã€‘`);
  outputLines.push(`CCB<=${con * 5} ã€CON Ã— 5ã€‘`);
  outputLines.push(`CCB<=${pow * 5} ã€POW Ã— 5ã€‘`);
  outputLines.push(`CCB<=${dex * 5} ã€DEX Ã— 5ã€‘`);
  outputLines.push(`CCB<=${app * 5} ã€APP Ã— 5ã€‘`);
  outputLines.push(`CCB<=${siz * 5} ã€SIZ Ã— 5ã€‘`);
  outputLines.push(`CCB<=${int * 5} ã€INT Ã— 5ã€‘`);
  outputLines.push(`CCB<=${edu * 5} ã€EDU Ã— 5}`);

  document.getElementById("output").value = outputLines.join("\n");
}

function copyOutput() {
  const output = document.getElementById("output");
  navigator.clipboard.writeText(output.value).then(() => {
    alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
    gtag('event', 'copy_output', {
      'event_category': 'button',
      'event_label': 'ã‚³ãƒ”ãƒ¼',
      'value': 1
    });
  }).catch(err => {
    alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err);
  });
}
</script>

</body>
</html>
