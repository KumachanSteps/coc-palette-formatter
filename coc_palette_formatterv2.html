
<!DOCTYPE html>
<html lang="ja">
<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-NJD5JZML31"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NJD5JZML31');
</script>
<meta charset="UTF-8">
<title>CoCã‚­ãƒ£ãƒ©ã‚·ãƒ¼ãƒˆæ•´å½¢ãƒ„ãƒ¼ãƒ« V2</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 40px;
  background-color: #f9f9f9;
  display: flex;
  flex-direction: column;
  align-items: center;
}
header {
  margin-bottom: 30px;
  text-align: center;
}
header h1 {
  font-size: 28px;
  color: #333;
}
header p {
  font-size: 14px;
  color: #555;
}
.main {
  display: flex;
  justify-content: center;
  gap: 30px;
  max-width: 1200px;
  width: 100%;
}
.container {
  flex: 1;
  display: flex;
  flex-direction: column;
  max-width: 550px;
}
textarea {
  width: 100%;
  height: 600px;
  resize: none;
  padding: 10px;
  font-family: monospace;
  font-size: 14px;
  background-color: #fff;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-sizing: border-box;
}
button {
  margin-top: 10px;
  padding: 10px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  background-color: #007acc;
  color: #fff;
  transition: background-color 0.3s;
}
button:hover {
  background-color: #005f99;
}
</style>
</head>
<body>

<header>
  <h1>CoCã‚­ãƒ£ãƒ©ã‚·ãƒ¼ãƒˆæ•´å½¢ãƒ„ãƒ¼ãƒ« V2</h1>
  <p>ã€ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä¿ç®¡æ‰€ã€ã®ã€Œãƒ‡ãƒ¼ã‚¿å‡ºåŠ›â–¶ï¸ãƒ†ã‚­ã‚¹ãƒˆã€ã‚’ãƒãƒ£ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆã«æ•´å½¢ã—ã¾ã™ã€‚</p>
</header>

<div class="main">
  <div class="container">
    <textarea id="input" placeholder="ã“ã“ã«ãƒãƒ£ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„"></textarea>
    <button onclick="formatPalette()">åˆ†é¡ã—ã¦å‡ºåŠ›</button>
  </div>

  <div class="container">
    <textarea id="output" readonly></textarea>
    <button onclick="copyOutput()">ã‚³ãƒ”ãƒ¼</button>
  </div>
</div>

<script>
const initialValues = {
  'ã‚­ãƒƒã‚¯': 25, 'çµ„ã¿ä»˜ã': 25, 'é ­çªã': 10, 'æŠ•æ“²': 25, 'ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„': 1,
  'æ‹³éŠƒ': 20, 'ã‚µãƒ–ãƒã‚·ãƒ³ã‚¬ãƒ³': 15, 'ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³': 30, 'ãƒã‚·ãƒ³ã‚¬ãƒ³': 15, 'ãƒ©ã‚¤ãƒ•ãƒ«': 25,
  'å¿œæ€¥æ‰‹å½“': 30, 'éµé–‹ã‘': 1, 'éš ã™': 15, 'éš ã‚Œã‚‹': 10, 'å¿ã³æ­©ã': 10, 'å†™çœŸè¡“': 10, 'ç²¾ç¥åˆ†æ': 1,
  'è¿½è·¡': 10, 'ç™»æ”€': 40, 'é‹è»¢': 20, 'æ©Ÿæ¢°ä¿®ç†': 20, 'é‡æ©Ÿæ¢°æ“ä½œ': 1, 'ä¹—é¦¬': 5, 'æ°´æ³³': 25,
  'è£½ä½œ': 5, 'æ“ç¸¦': 1, 'è·³èº': 25, 'é›»æ°—ä¿®ç†': 10, 'ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ': 10, 'å¤‰è£…': 1,
  'è¨€ã„ãã‚‹ã‚': 5, 'ä¿¡ç”¨': 15, 'èª¬å¾—': 15, 'å€¤åˆ‡ã‚Š': 5,
  'åŒ»å­¦': 5, 'ã‚ªã‚«ãƒ«ãƒˆ': 5, 'åŒ–å­¦': 1, 'èŠ¸è¡“': 5, 'çµŒç†': 10, 'è€ƒå¤å­¦': 1, 'ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼': 1,
  'å¿ƒç†å­¦': 5, 'äººé¡å­¦': 1, 'ç”Ÿç‰©å­¦': 1, 'åœ°è³ªå­¦': 1, 'é›»å­å·¥å­¦': 1, 'å¤©æ–‡å­¦': 1, 'åšç‰©å­¦': 10, 'ç‰©ç†å­¦': 1, 'æ³•å¾‹': 5, 'è–¬å­¦': 1, 'æ­´å²': 20
};

function formatPalette() {
  const inputContent = document.getElementById("input").value;
  const lines = inputContent.split("\n");
  const categories = { dice: [], explore: [], battle: [], action: [], talk: [], knowledge: [], initial: [], status: [], damage: [] };
  const presentSkills = new Map();
  let str = 0, con = 0, pow = 0, dex = 0, app = 0, siz = 0, int = 0, edu = 0;
  let damageBonus = "0"; // Default damage bonus
  let sanValue = 70; // Default SAN value, will try to extract from input

  lines.forEach(line => {
    // Extract Ability Scores
    const statsMatch = line.match(/^=åˆè¨ˆ=\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/);
    if (statsMatch) {
      str = parseInt(statsMatch[1]);
      con = parseInt(statsMatch[2]);
      pow = parseInt(statsMatch[3]);
      dex = parseInt(statsMatch[4]);
      app = parseInt(statsMatch[5]);
      siz = parseInt(statsMatch[6]);
      int = parseInt(statsMatch[7]);
      edu = parseInt(statsMatch[8]);
    }

    // Extract Damage Bonus
    const damageBonusMatch = line.match(/ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒœãƒ¼ãƒŠã‚¹ï¼š(.+)/);
    if (damageBonusMatch) {
      damageBonus = damageBonusMatch[1].trim();
    }
    
    // Extract SAN value from input (e.g., SAN: 70/99)
    const sanMatch = line.match(/SANï¼š(\d+)\/\d+/);
    if (sanMatch) {
        sanValue = parseInt(sanMatch[1]);
    }

    // Skill parsing for input format: [â—]ã€ŠSkillNameã€‹Value%
    const skillMatch = line.match(/ã€Š(.+?)ã€‹\s*(\d+)%?/);
    if (skillMatch) {
      let skillName = skillMatch[1].trim();
      const skillValue = parseInt(skillMatch[2]);
      
      skillName = skillName.replace(/\(.*\)/, '').trim();

      // Store all found skills in presentSkills map
      presentSkills.set(skillName, skillValue);
    }
  });

  // --- Populate standard 'dice' rolls ---
  // Always include SAN roll, using extracted sanValue
  categories.dice.push(`1d100<=${sanValue} ã€æ­£æ°—åº¦ãƒ­ãƒ¼ãƒ«ã€‘`); 
  categories.dice.push(`CCB<=${presentSkills.get("ã‚¢ã‚¤ãƒ‡ã‚¢") || initialValues["ã‚¢ã‚¤ãƒ‡ã‚¢"] || 0} ã€ã‚¢ã‚¤ãƒ‡ã‚¢ã€‘`);
  categories.dice.push(`CCB<=${presentSkills.get("å¹¸é‹") || initialValues["å¹¸é‹"] || 0} ã€å¹¸é‹ã€‘`);
  categories.dice.push(`CCB<=${presentSkills.get("çŸ¥è­˜") || initialValues["çŸ¥è­˜"] || 0} ã€çŸ¥è­˜ã€‘`);

  // --- Populate standard 'explore' rolls ---
  categories.explore.push(`CCB<=${presentSkills.get("ç›®æ˜Ÿ") || initialValues["ç›®æ˜Ÿ"] || 0} ã€ç›®æ˜Ÿã€‘`);
  categories.explore.push(`CCB<=${presentSkills.get("èãè€³") || initialValues["èãè€³"] || 0} ã€èãè€³ã€‘`);
  categories.explore.push(`CCB<=${presentSkills.get("å›³æ›¸é¤¨") || initialValues["å›³æ›¸é¤¨"] || 0} ã€å›³æ›¸é¤¨ã€‘`);

  // --- Remaining skill categorizations (for skills not explicitly handled in dice/explore pre-population) ---
  // Iterate through presentSkills to categorize the rest
  presentSkills.forEach((skillValue, skillName) => {
    // Skip skills already explicitly added to dice or explore categories
    if (["ã‚¢ã‚¤ãƒ‡ã‚¢", "å¹¸é‹", "çŸ¥è­˜", "ç›®æ˜Ÿ", "èãè€³", "å›³æ›¸é¤¨", "SAN"].includes(skillName)) {
      return;
    }
    
    const formattedSkillLine = `CCB<=${skillValue} ã€${skillName}ã€‘`;

    // Categorization logic for remaining skills
    if (["å›é¿", "ã“ã¶ã—", "ã‚­ãƒƒã‚¯", "çµ„ã¿ä»˜ã", "é ­çªã", "æŠ•æ“²", "ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„", "æ‹³éŠƒ", "ã‚µãƒ–ãƒã‚·ãƒ³ã‚¬ãƒ³", "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³", "ãƒã‚·ãƒ³ã‚¬ãƒ³", "ãƒ©ã‚¤ãƒ•ãƒ«", "ã‚½ãƒ¼ãƒ‰", "æ—¥æœ¬åˆ€", "ãƒŠã‚¤ãƒ•"].some(s => skillName.includes(s)) || /^(å°ã•ãªæ£æ£’|å¤§ããªæ£æ£’|å°ã•ã„æ£æ£’|å¤§ãã„æ£æ£’)/.test(skillName)) {
        categories.battle.push(formattedSkillLine);
    } else if (["å¿œæ€¥æ‰‹å½“", "éµé–‹ã‘", "éš ã™", "éš ã‚Œã‚‹", "å¿ã³æ­©ã", "å†™çœŸè¡“", "ç²¾ç¥åˆ†æ", "è¿½è·¡", "ç™»æ”€", "é‹è»¢", "æ©Ÿæ¢°ä¿®ç†", "é‡æ©Ÿæ¢°æ“ä½œ", "ä¹—é¦¬", "æ°´æ³³", "è£½ä½œ", "æ“ç¸¦", "è·³èº", "é›»æ°—ä¿®ç†", "ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ", "å¤‰è£…"].some(s => skillName.includes(s)) || /^(é‹è»¢|è£½ä½œ|æ“ç¸¦)/.test(skillName)) {
        categories.action.push(formattedSkillLine);
    } else if (["è¨€ã„ãã‚‹ã‚", "ä¿¡ç”¨", "èª¬å¾—", "å€¤åˆ‡ã‚Š", "æ¯å›½èª", "ãã®ä»–è¨€èª"].some(s => skillName.includes(s))) {
        categories.talk.push(formattedSkillLine);
    } else if (["èŠ¸è¡“"].includes(skillName) || skillName.startsWith("èŠ¸è¡“")) {
        categories.knowledge.push(formattedSkillLine);
    } else if(["ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±", "åŒ»å­¦", "ã‚ªã‚«ãƒ«ãƒˆ", "åŒ–å­¦", "çµŒç†", "è€ƒå¤å­¦", "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼", "å¿ƒç†å­¦", "äººé¡å­¦", "ç”Ÿç‰©å­¦", "åœ°è³ªå­¦", "é›»å­å·¥å­¦", "å¤©æ–‡å­¦", "åšç‰©å­¦", "ç‰©ç†å­¦", "æ³•å¾‹", "è–¬å­¦", "æ­´å²"].some(s => skillName.includes(s))) {
        categories.knowledge.push(formattedSkillLine);
    } else {
        categories.knowledge.push(formattedSkillLine);
    }
  });


  // Generate initial values based on missing skills
  const missingInitials = Object.entries(initialValues)
    .filter(([skill, _]) => !presentSkills.has(skill))
    .map(([skill, value]) => `CCB<=${value} ã€${skill}ã€‘`);

  let actualDamageRoll = '';
  if (damageBonus === '0') {
    actualDamageRoll = '1d3+0 ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€‘';
  } else if (damageBonus === '+1d4') {
    actualDamageRoll = '1d4+0 ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€‘';
  } else if (damageBonus === '+1d6') {
    actualDamageRoll = '1d6+0 ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€‘';
  } else {
    actualDamageRoll = '1d3+0 ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€‘'; // Fallback
  }

  const abilityScoreLines = [
    `CCB<=${str * 5} ã€STR Ã— 5ã€‘`,
    `CCB<=${con * 5} ã€CON Ã— 5ã€‘`,
    `CCB<=${pow * 5} ã€POW Ã— 5ã€‘`,
    `CCB<=${dex * 5} ã€DEX Ã— 5ã€‘`,
    `CCB<=${app * 5} ã€APP Ã— 5ã€‘`,
    `CCB<=${siz * 5} ã€SIZ Ã— 5ã€‘`,
    `CCB<=${int * 5} ã€INT Ã— 5ã€‘`,
    `CCB<=${edu * 5} ã€EDU Ã— 5}`
  ];

  const output = [
    "â—¼ï¸ãƒ€ã‚¤ã‚¹",
    ...categories.dice,
    "\nğŸŸ¦æ¢ç´¢æŠ€èƒ½",
    ...categories.explore,
    "\nğŸŸ¥æˆ¦é—˜æŠ€èƒ½",
    ...categories.battle,
    "\nğŸŸ§è¡Œå‹•æŠ€èƒ½ãƒ»ä»–",
    ...categories.action,
    "\nğŸŸªäº¤æ¸‰æŠ€èƒ½",
    ...categories.talk,
    "\nâ¬œï¸çŸ¥è­˜æŠ€èƒ½",
    ...categories.knowledge,
    "\n========åˆæœŸå€¤========",
    ...missingInitials,
    "\n========èƒ½åŠ›å€¤========",
    actualDamageRoll,
    ...abilityScoreLines
  ].join("\n");

  document.getElementById("output").value = output;
}

function copyOutput() {
  const output = document.getElementById("output");
  navigator.clipboard.writeText(output.value).then(() => {
    alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
    gtag('event', 'copy_output', {
      'event_category': 'button',
      'event_label': 'ã‚³ãƒ”ãƒ¼',
      'value': 1
    });
  }).catch(err => {
    alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err);
  });
}
</script>

</body>
</html>
